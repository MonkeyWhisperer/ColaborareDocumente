@page "/colaborare-documente"
@page "/colaborare-documente/{FolderId}"

@using Azure.Storage
@using Azure.Storage.Blobs.Models
@using Azure.Storage.Sas
@using BlazorBootstrap
@using ColaborareDocumente.Data
@using Microsoft.AspNetCore.Authorization;
@using Microsoft.AspNetCore.Identity;
@using System.Text.RegularExpressions
@using Microsoft.EntityFrameworkCore
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Forms
@using Azure.Storage.Blobs;
@using Syncfusion.Blazor.DropDowns;

@inject UserManager<ApplicationUser> _UserManager
@inject RoleManager<IdentityRole> _RoleManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ApplicationDbContext dbContext
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthenticationStateProvider

@inject IJSRuntime jsRuntime

@rendermode @(new InteractiveServerRenderMode(prerender:false))

<PageTitle>Colaborare Documente</PageTitle>

<h1 style="margin-bottom:0px;">Colaborare Documente</h1>

<ConfirmDialog @ref="dialog" />

<AuthorizeView>
    <Authorized>
        @* <Switch @bind-Value="afiseazaArhivaRece" Label="Afișeaza arhiva rece" /> *@

        @* Doar dacă nu suntem în pagina/folder sursă putem naviga direct în sursă *@
        @if (folderId > 0)
        {
            <a href="../colaborare-documente">Colaborare Documente</a>
        }

        @* Generare cale către părinții la care are acces *@
        @foreach (var folder in parentFolders)
        {
            <span> / </span>
            <a href="../colaborare-documente/@folder.FolderId">@folder.FolderName</a>
        }


        @if (folderId > 0)
        {
            <span> / <b>@headerName</b></span>

            <div style="height:10px;"></div>
        }

        @if (!isBackendOperationComplete)
        {
            <div style="height:34px;"></div>
        }

        @if (isBackendOperationComplete && folderId < 0 && parentFolders.Count() == 0)
        {
            <div style="height:34px;">Începe explorarea</div>
        }


        @if (@context.User.IsInRole(ADMINISTRATION_ROLE))
        {
            <button class="btn btn-success float-start" @onclick="(() => AddNewFolder())">Adaugă Folder</button>
        }
        else if (folderId > 0)
        {
            <button class="btn btn-success float-start" @onclick="(() => AddNewFolder())">Adaugă Folder</button>
        }

        @if (folderId > 0)
        {
            <div class="file-input-wrapper">
                <div class="file-input-button">Încarcă Documente</div>
                <InputFile class="file-input" multiple OnChange="HandleSelectedFiles" />
            </div>
        }





        <table class="table">
            <thead>
                <tr>
                    <th>Nume</th>
                    <th width="200px">Ultima modificare</th>
                    <th width="100px"></th>
                </tr>
            </thead>
            <tbody>
                @foreach (var folder in folders)
                {
                // Creează un rând pentru fiecare folder din lista de foldere
                    <tr style="cursor:pointer">
                        @* Creează o celulă cu un icon de folder și numele folderului, care navighează la folder la clic *@
                        <td @onclick="(() => ViewFolder(folder))">
                            <span class="bi bi-folder2" style="margin-right:5px;"></span>@folder.FolderName
                        </td>
                         @* Creează o celulă cu data ultimei modificări, care navighează la folder la clic *@
                        <td width="200px" @onclick="(() => ViewFolder(folder))">
                            @if (folder.LastModifiedDate.HasValue)
                            {
                                @folder.LastModifiedDate.Value.ToString("dd/MM/yyyy - HH:mm")
                                // Formatează data ultimei modificări
                            }
                        </td>
                         @* Creează o celulă cu un buton pentru editarea folderului *@
                        <td width="100px">
                            <button class="btn btn-primary" @onclick="(() => EditFolder(folder))">
                                Editează
                            </button>
                        </td>
                    </tr>
                }

                @foreach (var file in files)
                {
                // Creează un rând pentru fiecare fișier din lista de fișiere
                    <tr style="cursor:pointer; height:55px;">
                        @* Creează o celulă cu un icon de fișier și numele fișierului, care deschide fișierul la clic *@
                        <td @onclick="(() => ViewFile(file))">
                            <span class="bi bi-file-earmark-text" style="margin-right:5px;"></span>@file.FileName
                        </td>
                        @* Creează o celulă cu data ultimei modificări, care deschide fișierul la clic *@
                        <td width="200px" @onclick="(() => ViewFile(file))">
                            @if (file.LastModifiedDate.HasValue)
                            {
                                @file.LastModifiedDate.Value.ToString("dd/MM/yyyy - HH:mm")
                                // Formatează data ultimei modificări
                            }
                        </td>
                        @* Creează o celulă goală pentru viitoare funcționalități (de ex. butoane de acțiune) *@
                        <td width="100px" @onclick="(() => ViewFile(file))">
                        </td>
                    </tr>
                }

                @if (!folders.Any() && !files.Any())
                {
                // Afișează un mesaj dacă nu există foldere sau fișiere în listă
                    <tr>
                        <td colspan="3" class="text-center">Nu există foldere sau documente</td>
                    </tr>
                }
            </tbody>
        </table>
        @if (ShowPopup)
        {
            <!-- Acesta este popup-ul pentru crearea sau editarea unui utilizator -->
            <div class="modal" tabindex="-1" style="display:block" role="dialog">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            @if (objFolder.FolderId > 0)
                            {
                                <h3 class="modal-title">Editează Folder</h3>
                            }
                            else
                            {
                                <h3 class="modal-title">Adaugă Folder</h3>
                            }
                            <!-- Buton pentru închiderea popup-ului -->
                            <button type="button" class="close" style="padding-left: 9px; padding-right: 8px;"
                                    @onclick="ClosePopup">
                                <span aria-hidden="true">X</span>
                            </button>
                        </div>
                        <!-- Formular de editare pentru prognoza curentă -->
                        <div class="modal-body">
                            <input class="form-control" type="text"
                                   placeholder="Nume Folder"
                                   @bind="objFolder.FolderName" />
                            <span style="color:red">@validationFolderName</span>

                            <br />
                            @* <span>Acces Studenți</span> *@
                            <SfMultiSelect TValue="string[]" TItem="ApplicationUser" Placeholder="Access Utilizatori" DataSource="@Studenti" @bind-Value="@selectedUserIds">
                                <MultiSelectFieldSettings Text="FullName" Value="Id"></MultiSelectFieldSettings>
                            </SfMultiSelect>

                            <br />
                            <br />

                            <!-- Arată butonul de ștergere doar dacă nu este un nou înregistrare -->
                            @if (objFolder.FolderId > 0)
                            {
                                <!-- Buton pentru salvarea utilizatorului -->
                                <button class="btn btn-primary"
                                        @onclick="SaveFolder">
                                    Actualizează
                                </button>
                                <!-- Buton pentru ștergerea prognozei -->
                                @*      <button class="btn btn-danger float-end"
                        @onclick="(() => DeleteFolder(objFolder))">
                        Arhivează
                        </button> *@
                            }
                            else
                            {
                                <!-- Buton pentru salvarea utilizatorului -->
                                <button class="btn btn-primary"
                                        @onclick="SaveFolder">
                                    Finalizează
                                </button>
                            }
                            <br />
                            <span style="color:red">@strError</span>
                        </div>
                    </div>
                </div>
            </div>
        }

    </Authorized>
    <NotAuthorized>
        <p>Nu sunteți autentificat.</p>
    </NotAuthorized>
</AuthorizeView>
@code {
    private bool isBackendOperationComplete = false;

    private string[] selectedUserIds;

    private bool afiseazaArhivaRece = false;
    string validationFolderName = "";
    private ElementReference fileInput;

    [CascadingParameter]
    private Task<AuthenticationState> authenticationStateTask { get; set; }

    string ADMINISTRATION_ROLE = "Administrator";
    System.Security.Claims.ClaimsPrincipal CurrentUser;

    // Proprietate utilizată pentru adăugarea sau editarea utilizatorului selectat în prezent
    ApplicationUser objUser = new ApplicationUser();
    Folder objFolder = new Folder();

    // Urmărește rolul selectat pentru utilizatorul curent selectat
    string CurrentUserRole { get; set; } = "Student";

    // Colecție pentru a afișa utilizatorii existenți
    List<ApplicationUser> Studenti = new List<ApplicationUser>();

    // Opțiuni de afișat în dropdown-ul rolurilor atunci când se editează un utilizator
    List<string> Options = new List<string>() { "Student", "Administrator" };

    // Pentru a reține eventualele erori
    string strError = "";

    // Pentru a permite afișarea popup-ului
    bool ShowPopup = false;

    // SAU dacă așteptați un întreg și doriți să îl faceți nullable
    [Parameter]
    public string FolderId { get; set; } // Nullable pentru tipurile de valori

    int folderId = -1;

    public string headerName = "";

    public List<Folder> parentFolders = new List<Folder>();
    public List<Folder> childFolders = new List<Folder>();

    public string loggedInUserId = "";
    public bool loggedInUserIsAdmin = false;

    protected override async Task OnInitializedAsync()
    {
        // Obțineți utilizatorul conectat curent
        CurrentUser = (await authenticationStateTask).User;

        // Obțineți starea autentificării și utilizatorul autentificat
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var loggedInUser = authState.User;

        // Obțineți ID-ul utilizatorului autentificat
        loggedInUserId = loggedInUser.FindFirst(c => c.Type.Equals(ClaimTypes.NameIdentifier))?.Value;

        // Verificați dacă utilizatorul este administrator
        if (loggedInUser.IsInRole(ADMINISTRATION_ROLE))
        {
            loggedInUserIsAdmin = true;
        }

        // Preluați lista de utilizatori din UserManager
        var users = _UserManager.Users.Select(x => new ApplicationUser
            {
                Id = x.Id,
                UserName = x.UserName,
                Email = x.Email,
                FirstName = x.FirstName,
                LastName = x.LastName,
                PhoneNumber = x.PhoneNumber,
            });

        // Pentru fiecare utilizator, obțineți rolurile și adăugați la lista Studenti dacă nu are un rol
        foreach (var item in users)
        {
            var roles = await _UserManager.GetRolesAsync(item); // Obțineți rolurile pentru utilizator
            item.RolName = roles.FirstOrDefault();
            if (item.RolName == null)
            {
                Studenti.Add(item);
            }
        }

        // Convertiți FolderId din string în int dacă este posibil
        if (int.TryParse(FolderId, out var id))
        {
            // FolderId a fost furnizat, continuați cu încărcarea detaliilor folderului
            folderId = id; // Utilizați această valoare pentru a încărca detaliile folderului
        }

        // Doar dacă nu e de tip sursă e necesară construirea navigării înapoi în părinți
        if (folderId > 0)
        {
            // Preluați detaliile folderului specificat
            var folder = await dbContext.Folders.Where(e => e.FolderId == folderId).FirstOrDefaultAsync();
            headerName = folder.FolderName;

            // Preluați toate folderele din baza de date
            var allFolders = await dbContext.Folders.ToListAsync();

            // Verificați dacă utilizatorul este administrator
            if (loggedInUserIsAdmin)
            {
                // Dacă utilizatorul este administrator, preluați toți părinții folderului până la rădăcină
                parentFolders = GetAllParentFoldersUntilRoot(folderId, allFolders);
            }
            else
            {
                // Dacă utilizatorul nu este administrator, preluați folderele la care are acces
                List<FolderAccess> accesibleFolders = await dbContext.FolderAccess
                 .Where(fa => fa.UserId == loggedInUserId) // filtrați după accesul utilizatorului curent
                 .ToListAsync();

                var accessibleFolderIds = new HashSet<int>(accesibleFolders.Select(f => f.FolderId));

                // Preluați toți părinții folderului până la rădăcină pentru utilizatorul curent
                parentFolders = GetAllParentFoldersUntilRootUser(folderId, allFolders, accessibleFolderIds);
            }
        }

        // Asigurați-vă că există un ADMINISTRATION_ROLE
        var RoleResult = await _RoleManager.FindByNameAsync(ADMINISTRATION_ROLE);
        if (RoleResult == null)
        {
            // Creați rolul ADMINISTRATION_ROLE dacă nu există
            await _RoleManager.CreateAsync(new IdentityRole(ADMINISTRATION_ROLE));
        }

        // Asigurați-vă că un utilizator numit admin@colaborare.cloud este Administrator
        var user = await _UserManager.FindByNameAsync("admin@colaborare.cloud");
        if (user != null)
        {
            // Verificați dacă admin@colaborare.cloud este în rolul de Administrator
            var UserResult = await _UserManager.IsInRoleAsync(user, ADMINISTRATION_ROLE);
            if (!UserResult)
            {
                // Puneți admin-ul în rolul de Administrator dacă nu este deja
                await _UserManager.AddToRoleAsync(user, ADMINISTRATION_ROLE);
            }
        }

        // Obțineți folderele disponibile pentru utilizator
        await GetFolders();
        // Obțineți fișierele disponibile pentru utilizator
        await GetFiles();

        // Indicați că operațiunile de backend sunt complete
        isBackendOperationComplete = true;
    }

    public List<Folder> GetAllChildFolders(int parentFolderId)
    {
        // Apelăm metoda recursivă pentru a obține toți copiii folderului și îi convertim într-o listă
        return GetAllChildFoldersRecursive(parentFolderId).ToList();
    }

    private IEnumerable<Folder> GetAllChildFoldersRecursive(int parentFolderId)
    {
        // Obține copiii direcți ai folderului curent
        var childFolders = dbContext.Folders.Where(f => f.ParentFolderId == parentFolderId).ToList();

        // Iterează prin fiecare folder copil
        foreach (var folder in childFolders)
        {
            // Returnează folderul curent
            yield return folder;

            // Returnează recursiv toți copiii folderului curent
            foreach (var childFolder in GetAllChildFoldersRecursive(folder.FolderId))
            {
                yield return childFolder;
            }
        }
    }


    private IReadOnlyList<IBrowserFile> selectedFiles;
    private bool isUploading = false;

    private async Task HandleSelectedFiles(InputFileChangeEventArgs e)
    {

        var selectedFiles = e.GetMultipleFiles();
        // Opțional, puteți limita numărul de fișiere
        // selectedFiles = e.GetMultipleFiles(maxAllowedFiles);

        // Presupunând că aveți șirul de conexiune la Azure Storage într-o variabilă numită connectionString
        string connectionString = "DefaultEndpointsProtocol=https;AccountName=colaboraredocumente;AccountKey=2VmbePT5IL3EpmVwXNvrIwbDeRlIFN9YCCVJVRB0licy59uhhjdpYzUhX3IHOYpdPQA/LFFzckLO+AStCRQqMg==;EndpointSuffix=core.windows.net";
        string containerName = "uab";
        var blobServiceClient = new BlobServiceClient(connectionString);
        var blobContainerClient = blobServiceClient.GetBlobContainerClient(containerName);

        isUploading = true;

        foreach (var file in selectedFiles)
        {
            var blobName = Guid.NewGuid().ToString() + "/" + file.Name;
            try
            {
                long maxAllowedSize = 1L * 1024 * 1024 * 1024 * 1024; // 1 Terabyte

                string contentType = GetMimeType(file.Name);

                // Definește BlobHttpHeaders
                var httpHeaders = new BlobHttpHeaders { ContentType = contentType }; // Exemplu pentru un fișier PDF

                // Obțineți o referință la BlobClient pentru blob-ul specific pe care doriți să-l încărcați
                var blobClient = blobContainerClient.GetBlobClient(blobName);

                // Creați BlobUploadOptions și includeți HttpHeaders
                var options = new BlobUploadOptions
                    {
                        HttpHeaders = httpHeaders
                    };

                // Utilizați BlobClient pentru a încărca fișierul cu opțiunile specificate
                await blobClient.UploadAsync(file.OpenReadStream(maxAllowedSize), options);

                // După încărcare, URL-ul blob-ului poate fi obținut din BlobClient
                var blobUrl = blobClient.Uri.AbsoluteUri;

                // Creați o nouă instanță a entității Folder
                var newFile = new File();

                // Setați proprietățile pentru noul folder
                newFile.FileName = file.Name;
                newFile.BlobName = blobName;
                newFile.BlobUrl = blobUrl;
                newFile.CreatedDate = DateTime.Now; // Presupunând că aveți un câmp pentru momentul în care folderul a fost creat
                newFile.LastModifiedDate = DateTime.Now; // Setați data ultimei modificări la acum

                // Presupunând că obțineți ID-ul utilizatorului curent așa cum ați făcut în operațiunea de actualizare
                newFile.CreatedBy = CurrentUser.FindFirst(ClaimTypes.NameIdentifier)?.Value; // Pentru ID-ul utilizatorului creator
                newFile.LastModifiedBy = CurrentUser.FindFirst(ClaimTypes.NameIdentifier)?.Value; // De asemenea, setați ultimul modificat de creator
                newFile.ParentFolderId = folderId;
                // Adăugați noul folder la DbSet<Folders> în DbContext-ul dvs.
                dbContext.Files.Add(newFile);

            }
            catch (Exception ex)
            {
            }
        }


        // Salvați modificările în baza de date
        await dbContext.SaveChangesAsync();

        isUploading = false;
        await GetFiles();
        // Declanșați orice actualizări UI sau modificări de stare
        StateHasChanged();
    }

    private static string GetMimeType(string fileName)
    {
        var mimeTypes = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase)
        {
            // Adăugați mai multe tipuri MIME aici, după cum este necesar
            {".txt", "text/plain"},
            {".pdf", "application/pdf"},
            {".doc", "application/msword"},
            {".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"},
            {".xls", "application/vnd.ms-excel"},
            {".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"},
            {".png", "image/png"},
            {".jpg", "image/jpeg"},
            {".jpeg", "image/jpeg"},
            {".gif", "image/gif"},
            {".csv", "text/csv"},
            // Adăugați alte mapări după cum este necesar
        };

        // Obțineți extensia fișierului
        string extension = Path.GetExtension(fileName);

        // Implicit la octet-stream pentru tipuri necunoscute
        return mimeTypes.TryGetValue(extension, out string mimeType) ? mimeType : "application/octet-stream";
    }

    private void ViewFolder(Folder folder)
    {
        // Utilizați NavigationManager pentru a naviga la pagina specifică
        // Dacă trebuie să transmiteți ID-ul folderului sau orice alt parametru, adăugați-l la URL
        NavigationManager.NavigateTo($"/colaborare-documente/{folder.FolderId}");
    }

    private async Task ViewFile(File file)
    {
        if (file != null && !string.IsNullOrEmpty(file.BlobUrl))
        {
            string input = file.BlobUrl;
            int lastSlashIndex = input.LastIndexOf('/');
            string substringAfterLastSlash = input.Substring(lastSlashIndex + 1);

            string storageConnectionString = "DefaultEndpointsProtocol=https;AccountName=colaboraredocumente;AccountKey=2VmbePT5IL3EpmVwXNvrIwbDeRlIFN9YCCVJVRB0licy59uhhjdpYzUhX3IHOYpdPQA/LFFzckLO+AStCRQqMg==;EndpointSuffix=core.windows.net";
            string containerName = "uab";
            string blobName = file.BlobName;

            string blobUrlWithSas = GenerateBlobSasUrl(storageConnectionString, containerName, blobName);

            // Deschideți URL-ul Blob al fișierului într-o nouă filă de browser
            // Notă: Acest lucru necesită injectarea și utilizarea IJSRuntime pentru a apela funcții JavaScript din Blazor

            var mobile = await jsRuntime.InvokeAsync<bool>("isDevice");
            if (mobile)
            {
                await jsRuntime.InvokeVoidAsync("open", blobUrlWithSas, "_self");
            }
            else
            {
                await jsRuntime.InvokeVoidAsync("open", blobUrlWithSas, "_blank");
            }
        }

    }

    public string GenerateBlobSasUrl(string storageConnectionString, string containerName, string blobName)
    {
        BlobServiceClient blobServiceClient = new BlobServiceClient(storageConnectionString);

        // Obțineți obiectul container client
        BlobContainerClient containerClient = blobServiceClient.GetBlobContainerClient(containerName);

        // Obțineți obiectul blob client
        BlobClient blobClient = containerClient.GetBlobClient(blobName);

        // Generați tokenul SAS pentru blob folosind BlobSasBuilder
        var sasBuilder = new BlobSasBuilder
            {
                BlobContainerName = containerName,
                BlobName = blobName,
                Resource = "b", // "b" pentru blob
                StartsOn = DateTimeOffset.UtcNow.AddMinutes(-5), // Opțional: pentru a compensa decalajul de timp
                ExpiresOn = DateTimeOffset.UtcNow.AddHours(1), // Token valabil pentru 1 oră
                Protocol = SasProtocol.Https // Utilizați HTTPS pentru securitate
            };

        // Specificați permisiuni de citire pentru SAS
        sasBuilder.SetPermissions(BlobSasPermissions.Read);

        // Notă: În SDK-ul actual Azure.Storage.Blobs, generăm tokenul SAS diferit:
        // Utilizați cheia de delegare a utilizatorului pentru generarea tokenului, dacă este disponibilă, altfel, reveniți la cheia contului, dacă este necesar.
        // Acest exemplu presupune utilizarea implicită a cheii contului din șirul de conexiune.

        // Generați tokenul SAS
        var sasToken = blobClient.GenerateSasUri(sasBuilder).Query;

        // Combinați URL-ul blob cu tokenul SAS
        string blobUrlWithSas = $"{blobClient.Uri}?{sasToken}";

        return blobUrlWithSas;
    }

    private List<Folder> folders = new List<Folder>();

    public async Task GetFolders()
    { 
        // Verificați dacă utilizatorul autentificat este administrator
        if (loggedInUserIsAdmin)
        {
            // Dacă utilizatorul este administrator, preluați toate folderele care nu sunt arhivate și care au folderId ca părinte,
            // ordonate descrescător după data ultimei modificări
            folders = await dbContext.Folders
                .Where(e => e.ParentFolderId == folderId && e.Archived == false)
                .OrderByDescending(e => e.LastModifiedDate)
                .ToListAsync();
        }
        else
        {
            // Dacă utilizatorul nu este administrator
            if (folderId < 0)
            {
                // Dacă folderId este negativ, preluați toate folderele la care utilizatorul are acces
                folders = await dbContext.Folders
                    .Join(dbContext.FolderAccess, // Alăturați folderele cu accesurile la foldere
                        folder => folder.FolderId, // din fiecare folder luați FolderId
                        access => access.FolderId, // din fiecare acces luați FolderId (unde se potrivesc)
                        (folder, access) => new { folder, access }) // selectați atât folderul cât și accesul când se potrivesc
                    .Where(fa => fa.access.UserId == loggedInUserId) // filtrați după accesul utilizatorului curent
                    .Select(fa => fa.folder) // selectați partea de folder a alăturării
                    .OrderByDescending(f => f.LastModifiedDate) // ordonați după data ultimei modificări
                    .ToListAsync();
            }
            else
            {
                // Dacă folderId este pozitiv, preluați folderele copil ale folderului specificat la care utilizatorul are acces
                folders = await dbContext.Folders
                    .Join(dbContext.FolderAccess, // Alăturați folderele cu accesurile la foldere
                        folder => folder.FolderId, // din fiecare folder luați FolderId
                        access => access.FolderId, // din fiecare acces luați FolderId (unde se potrivesc)
                        (folder, access) => new { folder, access }) // selectați atât folderul cât și accesul când se potrivesc
                    .Where(fa => fa.access.UserId == loggedInUserId // filtrați după accesul utilizatorului curent
                                && fa.folder.ParentFolderId == folderId // și ID-ul folderului părinte specificat
                                && fa.folder.Archived == false) // și unde folderul nu este arhivat
                    .Select(fa => fa.folder) // selectați partea de folder a alăturării
                    .OrderByDescending(f => f.LastModifiedDate) // ordonați după data ultimei modificări
                    .ToListAsync();
            }

            // Obțineți setul de ID-uri ale folderelor părinți
            var parentFolderIds = folders.Select(f => f.FolderId).ToHashSet();

            // Filtrați folderele pentru a elimina cele care sunt copii ale altor foldere selectate
            folders = folders
                .Where(f => f.ParentFolderId == null || !parentFolderIds.Contains(f.ParentFolderId))
                .ToList();
        }
    }


    private List<File> files = new List<File>();

    public async Task GetFiles()
    {
        // goliți orice mesaje de eroare
        strError = "";

        files = await dbContext.Files.Where(e => e.ParentFolderId == folderId && e.Archived == false).OrderByDescending(e => e.LastModifiedDate).ToListAsync();
    }

    async Task AddNewFolder()
    {
        objFolder = new Folder();

        if (folderId > 0)
        {
            // Obțineți înregistrările FolderAccess pentru folder
            var folderAccessList = await dbContext.FolderAccess
                                                  .Where(fa => fa.FolderId == folderId)
                                                  .ToListAsync();

            // Extrageți ID-urile utilizatorilor din înregistrările FolderAccess
            selectedUserIds = folderAccessList.Select(fa => fa.UserId).ToArray();
        }

        ShowPopup = true;
    }

    async Task SaveFolder()
    {
        try
        {
            bool isValid = true;

            // Verifică dacă numele folderului este gol
            if (string.IsNullOrEmpty(objFolder.FolderName))
            {
                validationFolderName = "Câmpul Nume Folder este obligatoriu"; // Setează mesajul de validare
                isValid = false; // Setează flag-ul de validare ca fiind fals
            }
            else
            {
                validationFolderName = ""; // Golește mesajul de validare dacă numele folderului nu este gol
            }

            if (!isValid)
            {
                return; // Dacă nu este valid, se întoarce din funcție
            }

            // Verifică dacă acesta este un folder existent
            if (objFolder.FolderId > 0)
            {
                // Găsește folderul existent în baza de date
                var folder = await dbContext.Folders.FirstOrDefaultAsync(e => e.FolderId == objFolder.FolderId);

                folder.FolderName = objFolder.FolderName; // Actualizează numele folderului
                folder.LastModifiedDate = DateTime.Now; // Setează data ultimei modificări la momentul curent
                folder.LastModifiedBy = CurrentUser.FindFirst(ClaimTypes.NameIdentifier)?.Value; // Setează utilizatorul care a făcut ultima modificare

                await dbContext.SaveChangesAsync(); // Salvează modificările în baza de date
            }
            else
            {
                // Creează o nouă instanță a entității Folder
                var newFolder = new Folder();

                // Setează proprietățile pentru noul folder
                newFolder.FolderName = objFolder.FolderName; // Setează numele folderului
                newFolder.CreatedDate = DateTime.Now; // Setează data creării la momentul curent
                newFolder.LastModifiedDate = DateTime.Now; // Setează data ultimei modificări la momentul curent
                newFolder.CreatedBy = CurrentUser.FindFirst(ClaimTypes.NameIdentifier)?.Value; // Setează utilizatorul care a creat folderul
                newFolder.LastModifiedBy = CurrentUser.FindFirst(ClaimTypes.NameIdentifier)?.Value; // Setează utilizatorul care a făcut ultima modificare
                newFolder.ParentFolderId = folderId; // Setează ID-ul folderului părinte

                // Adaugă noul folder la DbSet<Folders> în DbContext-ul dvs.
                dbContext.Folders.Add(newFolder);

                // Salvează modificările în baza de date
                await dbContext.SaveChangesAsync();

                objFolder.FolderId = newFolder.FolderId; // Actualizează ID-ul folderului nou creat
            }

            // Închide popup-ul
            ShowPopup = false;

            // Obține toate folderele copil pentru folderul curent
            List<Folder> childFolders = GetAllChildFolders(objFolder.FolderId);

            // Șterge toate înregistrările de acces existente pentru folderul specificat
            var existingAccesses = await dbContext.FolderAccess
                                                  .Where(fa => fa.FolderId == objFolder.FolderId)
                                                  .ToListAsync();
            dbContext.FolderAccess.RemoveRange(existingAccesses);

            // Adaugă înregistrări noi de acces pentru fiecare utilizator din selectedUserIds
            if (selectedUserIds != null)
            {
                foreach (var userId in selectedUserIds)
                {
                    // Creează o nouă înregistrare de acces
                    var newAccess = new FolderAccess
                        {
                            FolderId = objFolder.FolderId, // Setează ID-ul folderului
                            UserId = userId // Setează ID-ul utilizatorului
                        };
                    dbContext.FolderAccess.Add(newAccess); // Adaugă noua înregistrare de acces în DbContext
                }
            }
            // Iterează prin fiecare folder copil și actualizează înregistrările de acces
            foreach (Folder childFolder in childFolders)
            {
                // Șterge toate înregistrările de acces existente pentru folderul copil specificat
                existingAccesses = await dbContext.FolderAccess
                                                    .Where(fa => fa.FolderId == childFolder.FolderId)
                                                     .ToListAsync();
                dbContext.FolderAccess.RemoveRange(existingAccesses);

                // Adaugă înregistrări noi de acces pentru fiecare utilizator din selectedUserIds
                foreach (var userId in selectedUserIds)
                {
                    // Creează o nouă înregistrare de acces
                    var newAccess = new FolderAccess
                        {
                            FolderId = childFolder.FolderId, // Setează ID-ul folderului copil
                            UserId = userId // Setează ID-ul utilizatorului
                        };
                    dbContext.FolderAccess.Add(newAccess); // Adaugă noua înregistrare de acces în DbContext
                }
            }

            // Salvează toate modificările în baza de date
            await dbContext.SaveChangesAsync();

            // Actualizează utilizatorii
            await GetFolders();
        }
        catch (Exception ex)
        {
            strError = ex.GetBaseException().Message; // Capturați și setați mesajul de eroare
        }
    }


    async Task EditFolder(Folder folder)
    {
        objFolder = folder;

        // Obțineți înregistrările FolderAccess pentru folder
        var folderAccessList = await dbContext.FolderAccess
                                              .Where(fa => fa.FolderId == folder.FolderId)
                                              .ToListAsync();

        // Extrageți ID-urile utilizatorilor din înregistrările FolderAccess
        selectedUserIds = folderAccessList.Select(fa => fa.UserId).ToArray();

        // Deschideți popup-ul
        ShowPopup = true;
    }

    private ConfirmDialog dialog;

    async Task DeleteFolder(Folder folder)
    {
        // Obțineți utilizatorul
        // var user = await _UserManager.FindByIdAsync(objUser.Id);

        var options = new ConfirmDialogOptions
            {
                YesButtonText = "Confirm",
                YesButtonColor = ButtonColor.Danger,
                NoButtonText = "Renunț",
                NoButtonColor = ButtonColor.Primary
            };

        var confirmation = await dialog.ShowAsync(
                 title: "Această acțiune necesită confirmare",
                 message1: "Confirmați arhivarea folderului " + folder.FolderName,
                 confirmDialogOptions: options);


        if (!confirmation)
        {
            return;
        }

        try
        {
            dbContext.Folders.Remove(folder); // Îndepărtați entitatea folder din context
            await dbContext.SaveChangesAsync(); // Salvați modificările în baza de date

            // Opțional, afișați un mesaj de succes sau efectuați alte acțiuni post-ștergere
        }
        catch (Exception ex)
        {
            // Gestionați orice erori care apar în timpul operațiunii de ștergere
            // De exemplu, înregistrați excepția și afișați un mesaj de eroare utilizatorului
            Console.WriteLine($"Eroare la ștergerea folderului: {ex.Message}");
            // În funcție de cadrul dvs. UI, puteți afișa aici o alertă utilizatorului
        }

        // Actualizați utilizatorii
        ShowPopup = false;
        await GetFolders();
    }

    async Task ClosePopup()
    {
        // Închideți popup-ul
        ShowPopup = false;
        await GetFolders();
    }

    public static Folder GetFolderById(int folderId, List<Folder> allFolders)
    {
        return allFolders.FirstOrDefault(f => f.FolderId == folderId);
    }

    public static List<Folder> GetAllParentFoldersUntilRoot(int childFolderId, List<Folder> allFolders)
    {
        // Creează o listă pentru a reține folderele părinte
        List<Folder> parentFolders = new List<Folder>();

        // Obține folderul curent pe baza ID-ului
        var currentFolder = GetFolderById(childFolderId, allFolders);

        // Buclează până când nu există niciun folder părinte
        while (currentFolder != null && currentFolder.ParentFolderId != null) 
        {
            // Obține folderul părinte pe baza ID-ului părintelui
            var parentFolder = GetFolderById(currentFolder.ParentFolderId, allFolders);
            if (parentFolder != null)
            {
                // Adaugă folderul părinte la listă
                parentFolders.Add(parentFolder);

                // Setează folderul curent ca fiind folderul părinte
                currentFolder = parentFolder;
            }
            else
            {
                // Niciun părinte valid găsit, ceea ce înseamnă că am ajuns la folderul cel mai de sus
                break;
            }
        }

        // Inversează lista pentru a avea ordinea corectă de la rădăcină la copil
        parentFolders.Reverse();

        // Returnează lista de foldere părinte
        return parentFolders;
    }

    public static List<Folder> GetAllParentFoldersUntilRootUser(int childFolderId, List<Folder> allFolders, HashSet<int> 
        accessibleFolderIds)
    {
        // Creează o listă pentru a reține folderele părinte
        List<Folder> parentFolders = new List<Folder>();

        // Obține folderul curent pe baza ID-ului
        var currentFolder = GetFolderById(childFolderId, allFolders);

        // Buclează până când nu există niciun folder părinte
        while (currentFolder != null && currentFolder.ParentFolderId != null) 
        {
            // Verifică dacă ID-ul părintelui folderului curent este în lista ID-urilor de foldere accesibile
            if (accessibleFolderIds.Contains(currentFolder.ParentFolderId))
            {
                // Obține folderul părinte pe baza ID-ului părintelui
                var parentFolder = GetFolderById(currentFolder.ParentFolderId, allFolders);
                if (parentFolder != null)
                {
                    // Adaugă folderul părinte la listă
                    parentFolders.Add(parentFolder);

                    // Setează folderul curent ca fiind folderul părinte
                    currentFolder = parentFolder;
                }
                else
                {
                    // Niciun părinte valid găsit, ceea ce înseamnă că am ajuns la folderul cel mai de sus
                    break;
                }
            }
            else
            {
                // Utilizatorul nu are acces la folderul părinte sau nu există părinte, întrerupe bucla
                break;
            }
        }

        // Inversează lista pentru a avea ordinea corectă de la rădăcină la copil
        parentFolders.Reverse();

        // Returnează lista de foldere părinte
        return parentFolders;
    }


    private async Task GoBack()
    {
        await jsRuntime.InvokeVoidAsync("history.back");
    }
}

<style>
    .file-input-wrapper {
        position: relative;
        width: max-content;
        float: left;
        margin-left: 10px;
        cursor: pointer;
    }

    .file-input-button {
        border: 1px solid #198754;
        background-color: #198754;
        color: white;
        padding: 0.38rem 1rem;
        border-radius: 0.4rem;
        font-size: 1rem;
        cursor: pointer;
        display: inline-block;
    }

    .file-input {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        opacity: 0;
        cursor: pointer;
    }

</style>
